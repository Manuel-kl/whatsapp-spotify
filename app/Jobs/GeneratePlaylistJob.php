<?php

namespace App\Jobs;

use App\Http\Controllers\AiController;
use App\Http\Controllers\Spotify\PlaylistController;
use App\Http\Controllers\Spotify\TrackController;
use App\Http\Controllers\WhatsappController;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Http\Request;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class GeneratePlaylistJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 600;

    public $tries = 3;

    protected ?string $jobId;

    protected string $activity;

    protected ?string $playlistName;

    protected ?string $playlistDescription;

    protected bool $isPublic;

    protected ?int $userId;

    protected ?string $whatsappPhone;

    public function __construct(
        string $activity,
        ?string $whatsappPhone = null,
        ?string $jobId = null,
        ?string $playlistName = null,
        ?string $playlistDescription = null,
        bool $isPublic = false,
        ?int $userId = null
    ) {
        $this->activity = $activity;
        $this->whatsappPhone = $whatsappPhone;
        $this->jobId = $jobId ?? uniqid('playlist_', true);
        $this->playlistName = $playlistName;
        $this->playlistDescription = $playlistDescription;
        $this->isPublic = $isPublic;
        $this->userId = $userId;
    }

    public function handle(): void
    {
        try {
            $this->updateProgress('fetching_data', 10, 'Analyzing your music taste...');

            $topTracksData = PlaylistController::getTopTracksData();
            $topArtistsData = PlaylistController::getTopArtistsData();

            $this->updateProgress('generating_songs', 30, 'Generating song recommendations...');

            $aiController = app(AiController::class);
            $aiResponse = $aiController->generatePlaylistSongs($this->activity);
            $recommendedSongs = $aiResponse['songs'];

            if (empty($recommendedSongs)) {
                throw new \Exception('No songs were generated by AI');
            }

            $playlistName = $this->playlistName ?? $aiController->generatePlaylistName($this->activity);

            $this->updateProgress('searching_tracks', 60, 'Finding tracks on Spotify...');

            $trackController = app(TrackController::class);
            $searchTerms = array_map(function ($song) {
                return $song['artist'].' '.$song['title'];
            }, $recommendedSongs);

            $allResults = [];
            $batchSize = 10;
            $batches = array_chunk($searchTerms, $batchSize);

            foreach ($batches as $index => $batch) {
                $searchRequest = new Request(['search_terms' => $batch, 'limit' => 3]);
                $searchResponse = $trackController->searchMultipleTracks($searchRequest);
                $batchResults = json_decode($searchResponse->getContent(), true);
                $allResults = array_merge($allResults, $batchResults['results']);

                $batchProgress = 60 + (($index + 1) / count($batches)) * 20;
                $this->updateProgress('searching_tracks', $batchProgress, 'Finding tracks on Spotify...');
            }

            $trackUris = [];
            $foundTracks = [];

            foreach ($allResults as $result) {
                if (!empty($result['tracks'])) {
                    $track = $result['tracks'][0];
                    $trackUris[] = $track['uri'];
                    $foundTracks[] = [
                        'search_term' => $result['search_term'],
                        'found_track' => $track['name'].' by '.$track['artists'][0]['name'],
                        'spotify_id' => $track['id'],
                        'uri' => $track['uri'],
                    ];
                }
            }

            if (empty($trackUris)) {
                throw new \Exception('No tracks found on Spotify for the AI recommendations');
            }

            $this->updateProgress('creating_playlist', 85, 'Creating your playlist...');

            $spotifyService = app(\App\Service\SpotifyService::class);
            $playlist = $spotifyService->createPlaylist(
                $playlistName,
                $this->playlistDescription ?? "Generated playlist for: {$this->activity}",
                $this->isPublic
            );

            $spotifyService->addTracksToPlaylist($playlist['id'], $trackUris);

            $result = [
                'success' => true,
                'playlist' => [
                    'id' => $playlist['id'],
                    'name' => $playlist['name'],
                    'description' => $playlist['description'],
                    'url' => $playlist['external_urls']['spotify'],
                    'tracks_added' => count($trackUris),
                    'name_generated_by_ai' => !$this->playlistName,
                ],
                'ai_recommendations' => $recommendedSongs,
                'found_tracks' => $foundTracks,
                'summary' => [
                    'ai_generated_songs' => count($recommendedSongs),
                    'spotify_tracks_found' => count($foundTracks),
                    'tracks_added_to_playlist' => count($trackUris),
                ],
            ];

            $this->updateProgress('completed', 100, 'Playlist created successfully!', $result);

            if ($this->whatsappPhone) {
                $this->sendWhatsAppNotification($result);
            }

        } catch (\Exception $e) {
            Log::error('Playlist generation failed', [
                'job_id' => $this->jobId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            $this->updateProgress('failed', 0, 'Failed to create playlist: '.$e->getMessage(), null, [
                'error' => $e->getMessage(),
                'code' => $e->getCode(),
            ]);

            if ($this->whatsappPhone) {
                $this->sendWhatsAppErrorNotification($e->getMessage());
            }

            throw $e;
        }
    }

    private function sendWhatsAppNotification(array $result): void
    {
        try {
            $whatsappController = app(WhatsappController::class);
            $playlist = $result['playlist'];

            $message = "ğŸµ Your playlist is ready!\n\n";
            $message .= "**{$playlist['name']}**\n";
            $message .= "ğŸ“Š {$playlist['tracks_added']} tracks added\n";
            $message .= "ğŸ§ Listen here: {$playlist['url']}";

            $whatsappController->sendWhatsAppMessage($this->whatsappPhone, $message, 'playlist_notification');
        } catch (\Exception $e) {
            Log::error('Failed to send WhatsApp notification', [
                'phone' => $this->whatsappPhone,
                'error' => $e->getMessage(),
            ]);
        }
    }

    private function sendWhatsAppErrorNotification(string $errorMessage): void
    {
        try {
            $whatsappController = app(WhatsappController::class);
            $message = "âŒ Sorry, I couldn't create your playlist.\n\nError: {$errorMessage}\n\nPlease try again later.";

            $whatsappController->sendWhatsAppMessage($this->whatsappPhone, $message, 'error_notification');
        } catch (\Exception $e) {
            Log::error('Failed to send WhatsApp error notification', [
                'phone' => $this->whatsappPhone,
                'error' => $e->getMessage(),
            ]);
        }
    }

    private function updateProgress(string $status, float $progress, string $message, ?array $result = null, ?array $error = null): void
    {
        $data = [
            'job_id' => $this->jobId,
            'status' => $status,
            'progress' => $progress,
            'message' => $message,
            'updated_at' => now()->toISOString(),
        ];

        if ($result !== null) {
            $data['result'] = $result;
        }

        if ($error !== null) {
            $data['error'] = $error;
        }

        Cache::put("playlist_job:{$this->jobId}", $data, 3600);
    }

    public function failed(\Throwable $exception): void
    {
        $this->updateProgress('failed', 0, 'Job failed: '.$exception->getMessage(), null, [
            'error' => $exception->getMessage(),
            'code' => $exception->getCode(),
        ]);

        if ($this->whatsappPhone) {
            $this->sendWhatsAppErrorNotification($exception->getMessage());
        }
    }
}
